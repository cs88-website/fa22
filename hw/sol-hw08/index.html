<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="description" content ="CS88: Computational Structures in Data Science" />
    <meta name="keywords" content ="CS88, Computer Science, Data Science, Programming, Berkeley, EECS" />
    <meta name="author" content ="Michael Ball, Anjali Gurajapu, Jessica Lin, Tommy Joseph, Lukas Chang, Karim Kaylani, Hetal Shah, Sebastian Zhao, Amit Sant, Michelle Chen, Christine Zhang, Ethan Yoo, Joanna Yoo" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <link rel="stylesheet" href="/fa22/assets/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/fa22/assets/css/style.css">
    <link rel="icon" href="/fa22/assets/images/favicon.ico">
    <link rel="stylesheet" href="/fa22/assets/css/mono-blue.css">

    <link rel="stylesheet" type="text/css" href="/fa22/assets/css/resource.css" />
<link rel="stylesheet" type="text/css" href="../../assets/css/hw.css"/>


    <title>Homework 8 Solutions | CS 88 Fall 2022</title>

  </head>

  <body id="index" class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-section" aria-label="Toggle Nav Menu" aria-expanded="false">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/fa22/">CS 88</a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse-section">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/fa22/">Calendar</a></li>
            <li><a href="/fa22/articles/resources.html">Resources</a></li>
            <li><a href="/fa22/weekly-schedule.html">Google Calendar</a></li>
            <li><a href="/fa22/articles/about.html">Syllabus</a></li>
            <li><a href="https://edstem.org/us/courses/25294/" target="_blank">Ed</a></li>
            <li><a href="/fa22/staff.html">Staff</a></li>
            <li><a href="https://oh.c88c.org/" target="_blank">OH Queue</a></li>
            <li><a href="https://tutor.cs61a.org/" target="_blank">Python Tutor</a></li>
            <li><a href="https://bcourses.berkeley.edu/courses/1518009/external_tools/78985" target="_blank">Recordings</a></li>
          </ul>
        </div>
      </div>
    </nav>

    

    <div id="content" class="container">
      <div class='row'>
  <div class='col-md-9'>
    <div class='page-header'>
      <span class="content-title-brand">Homework 8</span> Solutions
    </div>

    <p><strong>Solutions:</strong> You can find the file with solutions for all
questions <a href="hw08.py">here</a>.</p>

    

<p>Recall that the order of growth of a function expresses how long it
takes for the function to run, and is defined in terms of the
function's input sizes.</p>

<p>For example, let's say that we have the function <code>get_x</code> which is
defined as follows:</p>

<pre><code>def get_x(x):
    return x</code></pre>

<p><code>get_x</code> has one expression in it. That one expression takes the same
amount of time to run, no matter what x is, or more importantly, how
large x gets. This is called constant time, or O(1).</p>

<p>The main two ways that a function in your program will get a running
time different than just constant time is through either iteration or
recursion. Let's start with some iteration examples!</p>

<p>The (simple) way you figure out the running time of a particular while
loop is to simply count the cost of each operation in the body of the
while loop, and then multiply that cost by the number of times that the
loop runs. For example, look at the following method with a loop in
it:</p>

<pre><code>def foo(n):
    i = 1
    sum = 0
    while i &lt;= n:
        sum = sum + i
        i = i + 1
    return sum</code></pre>

<p>This loop has two statements in it <code>sum = sum + i</code> and <code>i = i + 1.</code>
Each statement is a constant time operation, since the amount of time each statement takes does not depend on the input to the function <code>n</code>.
In C88C, we are not concerned with how long primitive functions such as addition,
multiplication, and variable assignment take to run. Rather we are
concerned with <em>how many more times a loop is
executed</em> or <em>how many more recursive calls</em> occur as
the input increases. In this example, we execute the loop <code>n</code> times, and
for each iteration, we only execute constant time operations, so we get
an order of growth of O(<em>n</em>).</p>

<p>Here are a couple of basic functions, along with their running times.
Try to understand why they have the given running time.</p>

<p>O(n)</p>

<pre><code>def bar(n):
    i = 1
    a = 1
    b = 0
    while i &lt;= n:
        temp = a
        a = a + b
        b = temp
        i = i + 1
    return a</code></pre>

<p>O(n^2)</p>

<pre><code>def bar(n):
    sum = 0
    a, b = 0, 0
    while a &lt; n:
        while b &lt; n:
            sum += (a*b)
            b += 1
        b = 0
        a += 1
    return sum</code></pre>


<h2 id="efficiency">Efficiency</h2>


<p>There is nothing to submit for this part. But doing these problems will be good practice. The solutions are given right below the question and to see them you must highlight them.</p>

<p>For each question find the asymptotic runtime in big theta notation.</p>

<h3 class="question" id="q1">Question 1</h3>

<p>What is the asymptotic run time of the baz function.</p>

<pre><code>def baz(n):
    i = 1
    sum = 0
    while i &lt;= n:
        sum += bam(i)
        i += 1
    return sum

def bam(n):
    i = 1
    sum = 0
    while i &lt;= n:
        sum += i
        i += 1
    return sum</code></pre>

<solution>
Highlight the text on the line below this line to see the solution:
<br>
Answer: <span style="color:white">O(<em>n</em><sup>2</sup>))</span>.

</solution>

<h3 class="question" id="q2">Question 2</h3>

<pre><code>def bonk(n):
    sum = 0
    while n &gt;= 2:
        sum += n
        n = n / 2
    return sum</code></pre>

<solution>
Highlight the text on the line below this line to see the solution:
<br>
Answer: <span style="color:white">O(log(<em>n</em>))</span>.

</solution>


<h2 id="inheritance">Inheritance</h2>


<h3 class="question" id="q3">Question 3: Errors</h3>

<p>It is often said that nothing in life is certain but death and taxes. For a programmer or data scientist, however, nothing is certain but encountering errors.</p>

<p>In Python, there are two primary types of errors, both of which you are likely familiar with: syntax errors and exceptions. Syntax errors occur when the proper structure of the language is not followed, while exceptions are errors that occur during the execution of a program. These include errors such as ZeroDivisionError, TypeError, NameError, and many more!</p>

<p>Under the hood, these errors are based in the concepts of object orientation, and all exceptions are class objects. If you're interested in more detailed explanations of the structure of exceptions as well as how to create your own, check out this <a href="https://docs.python.org/2/library/exceptions.html">article</a> from the Python documentation! In the meantime, we'll implement our own version of an <code>Error</code> class</p>

<p>Complete the <code>Error</code>, <code>SyntaxError</code>, and <code>ZeroDivisionError</code> classes such that
they create the correct messages when called.</p>

<ul>
  <li>The <code>SyntaxError</code> and <code>ZeroDivisionError</code> classes inherit from the <code>Error</code> class and add functionality that is unique to those particular errors. Their code is partially implemented for you.</li>
  <li>The <code>add_code</code> method adds a new helpful message to your error, while the <code>write</code> method should print the output that you see when an error is raised. Do not worry if that code already is already defined; for this problem, it is safe to overwrite it.</li>
  <li>You can access the parent class methods using the <a href="https://docs.python.org/3/library/functions.html#super">super()</a> function</li>
</ul>

<solution>

<pre><code>class Error:
    &quot;&quot;&quot;
    &gt;&gt;&gt; err1 = Error(12, &quot;error.py&quot;)
    &gt;&gt;&gt; err1.write()
    error.py:12
    &quot;&quot;&quot;
    def __init__(self, line, file):
<span class="sol-highlight">        self.line = line
        self.file = file</span>

    def format(self):
        return self.file + &#x27;:&#x27; + str(self.line)

    def write(self):
        print(self.format())

class SyntaxError(Error):
    &quot;&quot;&quot;
    &gt;&gt;&gt; err1 = SyntaxError(17, &quot;lab10.py&quot;)
    &gt;&gt;&gt; err1.write()
    lab10.py:17 SyntaxError : Invalid syntax
    &gt;&gt;&gt; err1.add_code(4, &quot;EOL while scanning string literal&quot;)
    &gt;&gt;&gt; err2 = SyntaxError(18, &quot;lab10.py&quot;, 4)
    &gt;&gt;&gt; err2.write()
    lab10.py:18 SyntaxError : EOL while scanning string literal
    &quot;&quot;&quot;
    type = &#x27;SyntaxError&#x27;
    msgs = {0 : &quot;Invalid syntax&quot;, 1: &quot;Unmatched parentheses&quot;, 2: &quot;Incorrect indentation&quot;, 3: &quot;missing colon&quot;}

    def __init__(self, line, file, code=0):
<span class="sol-highlight">        super().__init__(line, file)
        self.message = self.msgs[code]</span>

    def format(self):
<span class="sol-highlight">        return super().format() + &#x27; &#x27; + self.type + &quot; : &quot; + self.message # or SyntaxError.msgs[self.code]</span>

    def add_code(self, code, msg):
<span class="sol-highlight">        SyntaxError.msgs[code] = msg</span>

class ZeroDivisionError(Error):
    &quot;&quot;&quot;
    &gt;&gt;&gt; err1 = ZeroDivisionError(273, &quot;lab10.py&quot;)
    &gt;&gt;&gt; err1.write()
    lab10.py:273 ZeroDivisionError : division by zero
    &quot;&quot;&quot;
    type = &#x27;ZeroDivisionError&#x27;

    def __init__(self, line, file, message=&#x27;division by zero&#x27;):
<span class="sol-highlight">        super().__init__(line, file)
        self.message = message</span>

    def format(self):
        end = self.type + &#x27; : &#x27; + self.message
<span class="sol-highlight">        return super().format() + &quot; &quot; + end</span></code></pre>

</solution>

<p>Use OK to test your code:</p><pre><code>python3 ok -q Error</code></pre>
<p>Use OK to test your code:</p><pre><code>python3 ok -q SyntaxError</code></pre>
<p>Use OK to test your code:</p><pre><code>python3 ok -q ZeroDivisionError</code></pre>

<h3 class="question" id="q4">Question 4: Checking account</h3>

<p>We'd like to be able to cash checks, so let's add a <code>deposit_check</code>
method to our <code>CheckingAccount</code> class. It will take a <code>Check</code> object
as an argument, and check to see if the <code>payable_to</code> attribute matches
the <code>CheckingAccount</code>'s holder. If so, it marks the <code>Check</code> as
deposited, and adds the amount specified to the <code>CheckingAccount</code>'s
total.</p>

<p>Write an appropriate <code>Check</code> class, and add the <code>deposit_check</code> method
to the <code>CheckingAccount</code> class. Make sure not to copy and paste code!
Use inheritance whenever possible.</p>

<p>See the doctests for examples of how this code should work.</p>

<p>The <code>Account</code> class has been provided.</p>

<solution>

<pre><code>class Account(object):
    &quot;&quot;&quot;A bank account that allows deposits and withdrawals.

    &gt;&gt;&gt; eric_account = Account(&#x27;Eric&#x27;)
    &gt;&gt;&gt; eric_account.deposit(1000000)   # depositing my paycheck for the week
    1000000
    &gt;&gt;&gt; eric_account.transactions
    [(&#x27;deposit&#x27;, 1000000)]
    &gt;&gt;&gt; eric_account.withdraw(100)      # buying dinner
    999900
    &gt;&gt;&gt; eric_account.transactions
    [(&#x27;deposit&#x27;, 1000000), (&#x27;withdraw&#x27;, 100)]
    &quot;&quot;&quot;

    interest = 0.02

    def __init__(self, account_holder):
        self.balance = 0
        self.holder = account_holder
        self.transactions = []

    def deposit(self, amount):
        &quot;&quot;&quot;Increase the account balance by amount and return the
        new balance.
        &quot;&quot;&quot;
        self.transactions.append((&#x27;deposit&#x27;, amount))
        self.balance = self.balance + amount
        return self.balance

    def withdraw(self, amount):
        &quot;&quot;&quot;Decrease the account balance by amount and return the
        new balance.
        &quot;&quot;&quot;
        self.transactions.append((&#x27;withdraw&#x27;, amount))
        if amount &gt; self.balance:
            return &#x27;Insufficient funds&#x27;
        self.balance = self.balance &#x2d; amount
        return self.balance

class CheckingAccount(Account):
    &quot;&quot;&quot;A bank account that charges for withdrawals.

    &gt;&gt;&gt; check = Check(&quot;Steven&quot;, 42)  # 42 dollars, payable to Steven
    &gt;&gt;&gt; steven_account = CheckingAccount(&quot;Steven&quot;)
    &gt;&gt;&gt; eric_account = CheckingAccount(&quot;Eric&quot;)
    &gt;&gt;&gt; eric_account.deposit_check(check)  # trying to steal steven&#x27;s money
    The police have been notified.
    &gt;&gt;&gt; eric_account.balance
    0
    &gt;&gt;&gt; check.deposited
    False
    &gt;&gt;&gt; steven_account.balance
    0
    &gt;&gt;&gt; steven_account.deposit_check(check)
    42
    &gt;&gt;&gt; check.deposited
    True
    &gt;&gt;&gt; steven_account.deposit_check(check)  # can&#x27;t cash check twice
    The police have been notified.
    &quot;&quot;&quot;
    withdraw_fee = 1
    interest = 0.01

    def withdraw(self, amount):
        return Account.withdraw(self, amount + self.withdraw_fee)

<span class="sol-highlight">    def deposit_check(self, check):
        if check.payable_to != self.holder or check.deposited:
            print(&quot;The police have been notified.&quot;)
        else:
            self.deposit(check.amount)
            check.deposited = True
            return self.balance</span>

class Check(object):
<span class="sol-highlight">    def __init__(self, payable_to, amount):
        self.payable_to = payable_to
        self.amount = amount
        self.deposited = False</span></code></pre>

</solution>

<p>Use OK to test your code:</p><pre><code>python3 ok -q CheckingAccount</code></pre>


<h2 id="submit">Submit</h2>


<p>Make sure to submit this assignment by running:</p>

<pre><code>python3 ok &#x2d;&#x2d;submit</code></pre>

  </div>

  <div class='col-md-3'>
    <nav class='hidden-print hidden-sm hidden-xs sidebar'>
      <ul>
  <li><a href="#efficiency">Efficiency</a></li>
  <ul>
  <li><a href="#q1">Question 1</a></li>
  <li><a href="#q2">Question 2</a></li>
</ul>

  <li><a href="#inheritance">Inheritance</a></li>
  <ul>
  <li><a href="#q3">Question 3: Errors</a></li>
  <li><a href="#q4">Question 4: Checking account</a></li>
</ul>

  <li><a href="#submit">Submit</a></li>
</ul>

    </nav>
  </div>

</div>
    </div>

    <script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
    <script src="/fa22/assets/js/bootstrap.min.js"></script>
    <!-- TODO: Move to specific pages... -->
    <script src="/fa22/assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
  $('.sidebar ul').addClass('nav nav-stacked');
  $('body').scrollspy({
    target: '.sidebar',
    offset: 40
  });
</script>

  </body>
</html>
